{
    "app_title": "Wiper",
    "drive_tip": "Select drive to wipe by double click. Be aware that entire\nphysical drive will be wiped, not a specific partition.",
    "value": "Byte to write",
    "value_tip": "Select the byte to overwrite (or to verify).\nThis is a hexadecimal value.",
    "blocksize": "Block size",
    "blocksize_tip": "Select the block size to read and write.\nFor SSDs this schould be the size of a memory\npage (4096 might work justr fine).",
    "maxbadblocks": "Max. bad blocks",
    "maxbadblocks_tip": "Select the maximum number of bad blocks\nbefore aborting the write operation.",
    "maxretries": "Max. retries",
    "maxretries_tip": "Select the maximum number of retries for\nfailed write operations befor aborting.",
    "tasks": {
        "selective": "Wipe used blocks/pages",
        "full": "Overwrite every byte",
        "extra": "2-pass wipe",
        "verify": "Do not wipe but verify"
    },
    "task_tip": "Select the wipe method (or just verify). The first option is designed for SSDs.\nEvery block (or memory pageg) is checked and will only be overwritten if data is present.",
    "create": {
        "gpt": "Create GPT partition table",
        "mbr": "Create MBR partition table",
        "none": "Do not touch drive after wiping"
    },
    "create_tip": "Select partition table to create after wiping.\n'Create GPT partition table' uses the modern standard.\n'Create MBR partition table' is a legacy method for drives up to 3TB.",
        "fs": {
        "ntfs": "Format to NTFS",
        "fat": "Format to FAT32",
        "exfat": "Format to exFAT",
        "none": "Do not format"
    },
    "fs_tip": "File system used for the new partition",

    "directory": "Directory",
    "source_dir_tip": "Add directory to be copied.\nThe field can also be filled\ndirectly (e.g. Ctrl+V).",
    "file_s": "File(s)",
    "source_file_tip": "Add file(s) to be copied.\nThe field can also be filled\ndirectly (e.g. Ctrl+V).",
    "destination": "Destination",
    "destination_tip": "Select the destination directory for the recursive copy operation.\nThe field can also be filled directly (e.g. Ctrl+V).",
    "hash": "Hash",
    "hash_tip": "Select hash algorithms if calculation is desired.\nThese will be saved in a CSV file in the log directory.",
    "verify_tip": "Select verification method (file size or hash value).\nAfter copying with Robocopy.exe, a comparison with\nthe source files can be performed.",
    "size": "Size",
    "log": "Log",
    "log_tip": "Select the directory for logging and possibly CSV file.\nIf the entry is left empty, no log will be created (except\nlastlog.txt in the application directory). The field can also\nbe filled directly (e.g. Ctrl+V).",
    "simulate_button": "Simulate",
    "stop_button": "Stop",
    "simulate_tip": "Shows which files would be created without actually copying.\nDuring the simulation, it can be aborted with this button.",
    "exec_button": "Start Copy Process",
    "exec_tip": "Start the recursive copy process. The\ndirectories and files to be copied are\nread from the field above.",
    "quit": "Quit",
    "quit_tip": "Exit the application.",
    "select_dir": "Select a directory to be copied.",
    "select_files": "Select file(s) to be copied.",
    "select_destination": "Select the destination directory to copy to.",
    "select_log": "Select the directory for logging.",
    "error": "Error",
    "warning": "Warning",
    "src_path_not_found": "Source path # was not found.",
    "no_source": "Source directories and/or files were not selected.",
    "already_added": "# has already been added.",
    "no_destination": "Destination directory was not selected.",
    "dst_no_dir": "Destination # is not a directory.",
    "dst_not_empty": "Destination directory # is not empty,\nfiles could be overwritten.\nContinue anyway?",
    "problems": "Problems occurred.",
    "invalid_dst_path": "Destination directory # is invalid.",
    "invalid_log_path": "Log directory # is invalid.",
    "log_required": "A log directory is required.",
    "invalid_path": "Path # is invalid.",
    "reading_source": "Reading structure of files and directories to be copied",
    "done_reading": "Reading completed",
    "total_size": "Total size",
    "starting_simulation": "Starting simulation of copy process",
    "existing": "Already exists!",
    "collisions": "# file(s) with the same name exist in the destination and could be overwritten",
    "simulation_finished": "The simulation of the copy process is complete",
    "simulation_aborted": "The simulation of the copy process was aborted",
    "starting_hashing": "Starting hash value calculation",
    "executing": "Executing: #",
    "robocopy_problem": "Robocopy had a problem, return value: #",
    "robocopy_finished": "Robocopy has finished",
    "starting_size_verification": "Starting verification based on file size",
    "of_files": "of # files",
    "mismatching_sizes": "File size mismatch: #",
    "size_check_finished": "Verification based on file size is complete",
    "waiting_end_hashing": "Waiting for the end of hash value calculation",
    "hashing_in_progress": "Continuing hash value calculation",
    "hashing_finished": "Hash value calculation is complete",
    "starting_hash_verification": "Starting verification based on hash value",
    "warning_sizes": "For # file(s), the size of the destination file does not match the source file",
    "hash_check_finished": "Verification based on hash value (#) is complete",
    "copy_finished": "Done - copying took # (hours, minutes, seconds)",
    "mismatches": "There were # mismatch(es)",
    "running_warning": "Copy process is running!\nDo you want to abort the copy process and exit the application?"
}